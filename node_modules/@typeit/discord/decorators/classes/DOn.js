"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Decorator_1 = require("./Decorator");
const __1 = require("../..");
class DOn extends Decorator_1.Decorator {
    constructor() {
        super(...arguments);
        this._compiledGuards = [];
        this._guards = [];
        this._hidden = false;
    }
    get linkedDiscord() {
        return this._linkedDiscord;
    }
    set linkedDiscord(value) {
        if (value) {
            this._linkedDiscord = value;
            if (this instanceof __1.DCommandNotFound) {
                this._linkedDiscord.commandNotFound = this;
            }
        }
    }
    get event() {
        return this._event;
    }
    set event(value) {
        this._event = value;
    }
    get hidden() {
        return this._hidden;
    }
    set hidden(value) {
        this._hidden = value;
    }
    get once() {
        return this._once;
    }
    set once(value) {
        this._once = value;
    }
    set guards(value) {
        this._guards = value;
        this.extractGuards();
    }
    static createOn(event, once) {
        const on = new DOn();
        on._event = event;
        on._once = once;
        return on;
    }
    bind() {
        this._method.bind(this._linkedDiscord.instance);
    }
    getMainFunction() {
        if (!this._mainFunction) {
            this.compileMainFunction();
        }
        return this._mainFunction;
    }
    // TOTEST: next function & next function params
    compileGuardFn() {
        const next = async (params, client, index, paramsToNext) => {
            const nextFn = () => next(params, client, index + 1, paramsToNext);
            const guardToExecute = this._compiledGuards[index];
            let res;
            if (index >= this._compiledGuards.length - 1) {
                let normalizedParams = params;
                if (this instanceof __1.CommandMessage) {
                    normalizedParams = params[0];
                }
                res = await guardToExecute(normalizedParams, client, paramsToNext);
            }
            else {
                // If it's a commmand, the params isn't a array, and the destructing with guard causes an error
                const normalizedParams = Array.isArray(params) ? params : [params];
                res = await guardToExecute(normalizedParams, client, nextFn, paramsToNext);
            }
            if (res) {
                return res;
            }
            return paramsToNext;
        };
        this._guardsFunction = (params, client) => next(params, client, 0, {});
    }
    // TOTEST: guard class binding
    extractGuards() {
        this._guards.map((guard) => {
            this._compiledGuards.push(guard.fn.bind(__1.DIService.instance.getService(guard.from)));
        });
        this._compiledGuards.push(this.method.bind(__1.DIService.instance.getService(this.from)));
    }
    compileMainFunction() {
        // Compiled mthods executes all the guards and the main method
        // compiledMethod = async (params: ArgsOf<any>, client: Client) => {
        //   guard1(params, client)
        //   guard2(params, client)
        //   guard3(params, client)
        //   main(params, client)
        // }
        this._mainFunction = async (params, client) => {
            const res = await this._guardsFunction(params, client);
            return {
                res,
                on: this,
                executed: true
            };
        };
        return this._mainFunction;
    }
}
exports.DOn = DOn;
//# sourceMappingURL=DOn.js.map