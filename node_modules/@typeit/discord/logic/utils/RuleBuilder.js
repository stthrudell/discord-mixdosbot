"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function Rule(expr, ...add) {
    return new RuleBuilder(expr, ...add);
}
exports.Rule = Rule;
// IDEA: Create an explicit description of what a command do (problem: i18n)
class RuleBuilder {
    constructor(expr, ...add) {
        this._source = "";
        this._flags = "i";
        this.fromExpression(expr);
        if (add.length > 0) {
            this.add(...add);
        }
    }
    get from() {
        return this._from;
    }
    set from(value) {
        this._from = value;
    }
    get source() {
        return this._source;
    }
    get flags() {
        return this._flags;
    }
    get regex() {
        return new RegExp(this._source, this._flags);
    }
    static validate(text, rules) {
        console.log(text, rules);
        return true;
    }
    static fromArray(exprs) {
        return exprs.map((expr) => Rule(expr));
    }
    static fromArgsRuleArray(argsRules) {
        return [];
    }
    static joinSources(joinChar, ...exprs) {
        return RuleBuilder.fromArray(exprs).map(rb => rb.source).join(Rule(joinChar).source);
    }
    static joinFlags(...exprs) {
        const flags = RuleBuilder.fromArray(exprs).map(rb => rb.flags);
        return flags.filter((f, i) => flags.indexOf(f) === i).join("");
    }
    static join(joinChar, ...exprs) {
        const source = this.joinSources(joinChar, ...exprs);
        let flags = this.joinFlags(...exprs);
        // flags: "ig", "ig", "i" => remove "g" because one of them doesn't have the "g" flag
        exprs.map((expr) => {
            const rule = Rule(expr);
            if (!rule.flags.includes(flags)) {
                flags = rule.flags.replace(RegExp(flags, "g"), "");
            }
        });
        return Rule(source).setFlags(flags);
    }
    static escape(text) {
        if (typeof text === "string") {
            return text.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        return text;
    }
    static isExpression(obj) {
        const exprType = this.typeOfExpression(obj);
        return [String, RuleBuilder, RegExp].includes(exprType);
    }
    static typeOfExpression(expr) {
        if (typeof expr === "string") {
            return String;
        }
        if (typeof expr === "function") {
            return Function;
        }
        if (expr instanceof RegExp) {
            return RegExp;
        }
        if (expr instanceof RuleBuilder) {
            return RuleBuilder;
        }
    }
    static or(...exprs) {
        let source = "(";
        exprs.map((expr, index) => {
            source += Rule(expr).source;
            if (index < exprs.length - 1) {
                source += "|";
            }
            return expr;
        });
        source += ")";
        return source;
    }
    /**
     * Create a copy of the current rule
     */
    copy() {
        const copy = new RuleBuilder();
        copy._source = this.source;
        copy._from = this._from;
        copy._flags = this._flags;
        return copy;
    }
    addParam(name) {
        return this.add();
    }
    /**
     * Add expressions to the end of your rule
     * @param exprs Expressions to add
     */
    add(...exprs) {
        const source = RuleBuilder.joinSources("", ...exprs);
        this.setFlags(RuleBuilder.joinFlags(this, ...exprs));
        this._source += source;
        return this;
    }
    /**
     * Add flags to your regex rule
     * @param flags the Regex flags
     */
    addFlags(...flags) {
        this._flags += flags.join("");
        return this;
    }
    /**
     * Set the flags of your regex rule
     * @param flags the Regex flags
     */
    setFlags(...flags) {
        this._flags = flags.join("");
        return this;
    }
    space(exprToAdd) {
        return this.add(RuleBuilder.atLeastOneSpace, exprToAdd);
    }
    strictSpace(exprToAdd) {
        return this.add(RuleBuilder.space, exprToAdd);
    }
    setSource(source) {
        this._source = source;
        return this;
    }
    /**
     * Add \s{1,}
     */
    haveSpaceAfter() {
        this._source += RuleBuilder.atLeastOneSpace;
        return this;
    }
    /**
     * Add "^" before your expression
     */
    start() {
        this.addBefore("^");
        return this;
    }
    /**
     * Add "^" before your expression => ^prefix
     * @param prefix The string must start with this
     */
    startWith(prefix) {
        this.addBefore(`^${Rule(prefix).source}`);
        return this;
    }
    /**
     * Add $
     */
    end() {
        this.add("$");
        return this;
    }
    /**
     * Move your index to the begining of your expression
     * Rule("c").before("a", "b") returns "abc"
     * @param exprs The expressions that you want to add before
     */
    before(...exprs) {
        this.addBefore(RuleBuilder.joinSources("", ...exprs));
        this.setFlags(RuleBuilder.joinFlags(this, ...exprs));
        return this;
    }
    spaceOrEnd() {
        return this.addOr(RuleBuilder.atLeastOneSpace, RuleBuilder.end);
    }
    /**
     * Create a Regex or
     * Rule().or("\\s{1,}", "$") returns "(\s{1,}|$)"
     * @param exprs The expressions to make an or with
     */
    addOr(...exprs) {
        this.add(RuleBuilder.or(...exprs));
        return this;
    }
    /**
     * Add before your expression
     * Rule("b").addBefore("a") returns "ab"
     * @param exprs The expressions to add before
     */
    addBefore(...exprs) {
        const source = RuleBuilder.joinSources("", ...exprs);
        this._source = `${source}${this._source}`;
        return this;
    }
    /**
     * Create an or condition
     * Rule("a").if(r => r.source.startWith("a"), r => r.add("b")) returns "ab"
     * Rule("b").if(r => r.source.startWith("a"), r => r.add("b")) returns "a"
     *
     * @param cond The condition function, it receive the copied Rule at the first parameter and must return a boolean value
     * @param then It receive the Rule reference at the first parameter
     */
    if(cond, then) {
        if (cond(this.copy())) {
            then(this);
        }
        return this;
    }
    /**
     * Set the expression to case sensitive
     */
    caseSensitive() {
        this._flags = this._flags.replace(/i/g, "");
        return this;
    }
    fromRegex(regex) {
        this._source = regex.source;
        this._flags = regex.flags;
        this._from = RegExp;
        return this;
    }
    fromString(str) {
        this._source = str;
        this._from = String;
        return this;
    }
    fromRule(rule) {
        this._source = rule._source;
        this._flags = rule._flags;
        this._from = RuleBuilder;
        return this;
    }
    fromExpression(expr) {
        if (expr) {
            switch (RuleBuilder.typeOfExpression(expr)) {
                case String:
                    return this.fromString(expr);
                case RegExp:
                    return this.fromRegex(expr);
                case RuleBuilder:
                    return this.fromRule(expr);
            }
        }
        return this;
    }
}
exports.RuleBuilder = RuleBuilder;
RuleBuilder.start = "^";
RuleBuilder.end = "$";
RuleBuilder.caseInsensitiveFlag = "i";
RuleBuilder.space = "\\s";
RuleBuilder.atLeastOne = "{1,}";
RuleBuilder.atLeastOneSpace = RuleBuilder.space + RuleBuilder.atLeastOne;
RuleBuilder.atLeastOneSpaceOrEnd = "(\\s{1,}|$)";
//# sourceMappingURL=RuleBuilder.js.map