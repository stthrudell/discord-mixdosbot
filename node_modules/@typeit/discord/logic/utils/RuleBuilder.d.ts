import { Expression, ArgsRulesFunction, ExpressionFunction } from "../..";
export declare function Rule(expr?: Expression, ...add: (string | RegExp)[]): RuleBuilder;
export declare class RuleBuilder {
    static readonly start = "^";
    static readonly end = "$";
    static readonly caseInsensitiveFlag = "i";
    static readonly space = "\\s";
    static readonly atLeastOne = "{1,}";
    static readonly atLeastOneSpace: string;
    static readonly atLeastOneSpaceOrEnd = "(\\s{1,}|$)";
    private _source?;
    private _flags;
    private _from?;
    get from(): StringConstructor | RegExpConstructor | typeof RuleBuilder;
    set from(value: StringConstructor | RegExpConstructor | typeof RuleBuilder);
    get source(): string;
    get flags(): string;
    get regex(): RegExp;
    constructor(expr?: Expression, ...add: (string | RegExp)[]);
    static validate(text: string, rules: ArgsRulesFunction[]): boolean;
    static fromArray(exprs: Expression[]): RuleBuilder[];
    static fromArgsRuleArray<Type extends Expression = Expression>(argsRules: ArgsRulesFunction<Type>[]): ArgsRulesFunction<RuleBuilder>[];
    static joinSources(joinChar: Expression, ...exprs: Expression[]): string;
    static joinFlags(...exprs: Expression[]): string;
    static join(joinChar: RuleBuilder, ...exprs: Expression[]): RuleBuilder;
    static escape(text: Expression): Expression;
    static isExpression(obj: any): boolean;
    static typeOfExpression(expr: Expression | ExpressionFunction): FunctionConstructor | StringConstructor | RegExpConstructor | typeof RuleBuilder;
    static or(...exprs: Expression[]): string;
    /**
     * Create a copy of the current rule
     */
    copy(): RuleBuilder;
    addParam(name: string): this;
    /**
     * Add expressions to the end of your rule
     * @param exprs Expressions to add
     */
    add(...exprs: Expression[]): this;
    /**
     * Add flags to your regex rule
     * @param flags the Regex flags
     */
    addFlags(...flags: string[]): this;
    /**
     * Set the flags of your regex rule
     * @param flags the Regex flags
     */
    setFlags(...flags: string[]): this;
    space(exprToAdd?: Expression): this;
    strictSpace(exprToAdd?: Expression): this;
    setSource(source: string): this;
    /**
     * Add \s{1,}
     */
    haveSpaceAfter(): this;
    /**
     * Add "^" before your expression
     */
    start(): this;
    /**
     * Add "^" before your expression => ^prefix
     * @param prefix The string must start with this
     */
    startWith(prefix: Expression): this;
    /**
     * Add $
     */
    end(): this;
    /**
     * Move your index to the begining of your expression
     * Rule("c").before("a", "b") returns "abc"
     * @param exprs The expressions that you want to add before
     */
    before(...exprs: Expression[]): this;
    spaceOrEnd(): this;
    /**
     * Create a Regex or
     * Rule().or("\\s{1,}", "$") returns "(\s{1,}|$)"
     * @param exprs The expressions to make an or with
     */
    addOr(...exprs: Expression[]): this;
    /**
     * Add before your expression
     * Rule("b").addBefore("a") returns "ab"
     * @param exprs The expressions to add before
     */
    addBefore(...exprs: Expression[]): this;
    /**
     * Create an or condition
     * Rule("a").if(r => r.source.startWith("a"), r => r.add("b")) returns "ab"
     * Rule("b").if(r => r.source.startWith("a"), r => r.add("b")) returns "a"
     *
     * @param cond The condition function, it receive the copied Rule at the first parameter and must return a boolean value
     * @param then It receive the Rule reference at the first parameter
     */
    if(cond: (ruleBuilder: RuleBuilder) => boolean, then: (ruleBuilder: RuleBuilder) => void): this;
    /**
     * Set the expression to case sensitive
     */
    caseSensitive(): this;
    fromRegex(regex: RegExp): this;
    fromString(str: string): this;
    fromRule(rule: RuleBuilder): this;
    fromExpression(expr?: Expression): this;
}
