"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CommandMessage_1 = require("../../types/public/CommandMessage");
const __1 = require("../..");
class MetadataStorage {
    constructor() {
        this._events = [];
        this._commands = [];
        this._commandNotFounds = [];
        this._guards = [];
        this._discords = [];
        this._modifiers = [];
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new MetadataStorage();
        }
        return this._instance;
    }
    static clear() {
        this._instance = new MetadataStorage();
    }
    get events() {
        return this._events;
    }
    get discords() {
        return this._discords;
    }
    get commands() {
        return this._commands;
    }
    get commandsNotFound() {
        return this._commandNotFounds;
    }
    addModifier(modifier) {
        this._modifiers.push(modifier);
    }
    addOn(on) {
        this._events.push(on);
    }
    addCommand(on) {
        this._commands.push(on);
        this.addOn(on);
    }
    addCommandNotFound(on) {
        this._commandNotFounds.push(on);
        this.addOn(on);
    }
    addGuard(guard) {
        this._guards.push(guard);
        __1.DIService.instance.addService(guard.classRef);
    }
    addDiscord(discord) {
        this._discords.push(discord);
        __1.DIService.instance.addService(discord.classRef);
    }
    async build() {
        // Link the events with their instances
        this._events = this._events.filter((on, index) => {
            const discord = this._discords.find((instance) => {
                return instance.from === on.classRef;
            });
            on.linkedDiscord = discord;
            // If the command is imported remove the original one
            if (on.hidden) {
                this.removeEvent(on);
                return false;
            }
            return true;
        });
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._commands);
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._commandNotFounds);
        await __1.Modifier.applyFromModifierListToList(this._modifiers, this._discords);
        this._events.map((on) => {
            on.guards = __1.DecoratorUtils.getLinkedObjects(on, this._guards);
            on.compileGuardFn();
        });
    }
    removeEvent(event) {
        const command = __1.DecoratorUtils.getLinkedObjects(event, this._commands)[0];
        if (command) {
            this._commands.splice(this._commands.indexOf(command), 1);
        }
        const commandNotFound = __1.DecoratorUtils.getLinkedObjects(event, this._commandNotFounds)[0];
        if (commandNotFound) {
            this._commandNotFounds.splice(this._commandNotFounds.indexOf(commandNotFound), 1);
        }
        return event;
    }
    trigger(event, client, once = false) {
        const responses = [];
        let eventsToExecute = this._events.filter((on) => {
            return on.event === event && on.once === once && !(on instanceof __1.DCommandNotFound);
        });
        return async (...params) => {
            let paramsToInject = params;
            const isMessage = event === "message";
            let isCommand = false;
            let notFoundOn;
            let onCommands = [];
            onCommands = (await Promise.all(this.events.map(async (on) => {
                if (isMessage && on instanceof __1.DCommand) {
                    const message = params[0];
                    isCommand = true;
                    let pass = undefined;
                    if (message.author.id === client.user.id) {
                        return;
                    }
                    const commandMessage = CommandMessage_1.CommandMessage.create(message, on);
                    const computedDiscordRules = (await Promise.all(on.linkedDiscord.argsRules.map(async (ar) => await ar(commandMessage, client)))).flatMap((rules) => {
                        return __1.RuleBuilder.join(__1.Rule(""), ...rules);
                    });
                    let computedCommandRules = (await Promise.all(on.argsRules.map(async (ar) => await ar(commandMessage, client))));
                    if (computedCommandRules.length <= 0) {
                        computedCommandRules = [[
                                __1.Rule(on.key).spaceOrEnd()
                            ]];
                    }
                    const allRules = computedDiscordRules.reduce((prev, cdr) => {
                        return [
                            ...computedCommandRules.map((ccr) => [
                                cdr,
                                ...__1.RuleBuilder.fromArray(ccr)
                            ]),
                            ...prev
                        ];
                    }, []).flatMap((rules) => {
                        const res = __1.RuleBuilder.join(__1.Rule(""), ...rules);
                        return [[
                                res.copy().setSource(res.source.replace(__1.Client.variablesExpression, "")),
                                res
                            ]];
                    });
                    // Test if the message match any of the rules
                    pass = allRules.find((rule) => {
                        return rule[0].regex.test(message.content);
                    });
                    if (pass) {
                        CommandMessage_1.CommandMessage.parseArgs(pass, commandMessage);
                        commandMessage.commandContent = commandMessage.content;
                        computedDiscordRules.map((cdr) => {
                            commandMessage.commandContent = commandMessage.commandContent.replace(cdr.regex, "");
                        });
                        paramsToInject = commandMessage;
                        return on;
                    }
                    else {
                        // If it doesn't pass any of the rules => execute the commandNotFound only on the discord instance that match the message discord rules
                        const passNotFound = computedDiscordRules.some((cdr) => {
                            return cdr.regex.test(message.content);
                        });
                        if (passNotFound) {
                            notFoundOn = on.linkedDiscord.commandNotFound;
                            paramsToInject = commandMessage;
                        }
                    }
                }
                else if (on.event === "message" &&
                    !(on instanceof __1.DCommandNotFound) &&
                    !(on instanceof __1.DCommand)) {
                    return on;
                }
                return undefined;
            }))).filter(c => c);
            if (isCommand) {
                const realCommands = onCommands.filter((e) => e instanceof __1.DCommand);
                const onsInCommands = onCommands.filter((e) => !(e instanceof __1.DCommand));
                if (realCommands.length > 0) {
                    eventsToExecute = onCommands;
                }
                else if (notFoundOn && realCommands.length <= 0) {
                    eventsToExecute = [
                        ...onsInCommands,
                        notFoundOn
                    ];
                }
                else if (onsInCommands.length > 0) {
                    eventsToExecute = onsInCommands;
                }
                else {
                    eventsToExecute = [];
                }
            }
            for (const on of eventsToExecute) {
                let injectedParams = paramsToInject;
                if (isCommand &&
                    !Array.isArray(injectedParams) &&
                    !(on instanceof __1.DCommand || on instanceof __1.DCommandNotFound)) {
                    injectedParams = [paramsToInject];
                }
                const res = await on.getMainFunction()(injectedParams, client);
                if (res.executed) {
                    responses.push(res.res);
                }
                if (res.on instanceof __1.DCommandNotFound) {
                    break;
                }
            }
            return responses;
        };
    }
}
exports.MetadataStorage = MetadataStorage;
//# sourceMappingURL=MetadataStorage.js.map